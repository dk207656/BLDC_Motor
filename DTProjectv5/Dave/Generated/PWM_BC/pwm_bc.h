/**
 * @file pwm_bc.h
 * @date 2015-10-08
 *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 * @cond
 ***********************************************************************************************************************
 * PWM_BC v4.0.16 - Generates PWM for block commutation (trapezoidal) using CCU8 and POSIF module.
 *
 * Copyright (c) 2015-2017, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-20:
 *     - Initial version
 *
 * 2015-06-20:
 *     - Sync start functionality updated
 *
 * @endcond
 *
 */


#ifndef PWM_BC_H_
#define PWM_BC_H_
/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/

#include <xmc_ccu8.h>
#include "xmc_scu.h"
#include <xmc_posif.h>
#include <xmc_gpio.h>
#include <DAVE_common.h>
#include "../GLOBAL_CCU8/global_ccu8.h"
#include "../GLOBAL_POSIF/global_posif.h"
#include "pwm_bc_conf.h"

#if (!((XMC_LIB_MAJOR_VERSION == 2U) && \
       (XMC_LIB_MINOR_VERSION >= 0U) && \
       (XMC_LIB_PATCH_VERSION >= 0U)))
#error "PWM_BC requires XMC Peripheral Library v2.0.0 or higher"
#endif


/**
 * @ingroup PWM_BC_constants
 * @{
 */
/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/
#define PWM_BC_MAXPHASE_COUNT    (3U)
/** Number of multi channel patterns */
#define PWM_BC_MAXMCP_COUNT      (6U)
/** Mask for service request node */
#define PWM_BC_SR_MSK            (3U)
/** deadtime register max count */
#define PWM_BC_DEADTIME_REG_MAX  (255U)
/** deadtime prescaler max value */
#define PWM_BC_DEADTIME_DIV_MAX  (3U)
/** constant for millisecond conversion*/
#define PWM_BC_MILLISECCONV      (1000U)
/** constant for microsecond conversion*/
#define PWM_BC_MICROSECCONV      (1000000U)
/** constant for nanosecond conversion*/
#define PWM_BC_NANOSECCONV       (1000000000U)
/** constant for dead time lower limit*/
#define PWM_BC_DEADTIME_MIN      (50U)
/** constant for dead time upper limit*/
#define PWM_BC_DEADTIME_MAX      (5000U)

#define PWM_BC_GetPhW(handleptr, index)  handleptr->saved_mc_pattern[0][index] >> ((4 * handleptr->phase_ptr[2]->slice_number) + handleptr->config_ptr->phw_cmpch)
/**
 * @}
 */

 /**********************************************************************************************************************
 * ENUMS
 **********************************************************************************************************************/
 /**
  * @ingroup PWM_BC_enumerations
  * @{
  */
  
/**
 * PWM modulation type
 */ 
typedef enum PWM_BC_MODULATIONTYPE
{
  PWM_BC_HIGHSIDE_MOD = 0,                        /*!<high side output is PWM modulated and low side output is either high or
                                                     low */
  PWM_BC_LOWSIDE_MOD,                             /*!<low side output PWM modulated and high side output is either high or
                                                     low */
  PWM_BC_SYNCHRONOUS_RECTIFICATION_MOD,           /*!<high side output is PWM modulated + complementary PWM for same leg low
                                                     side other low side output is either high or low*/
  PWM_BC_SYNCHRONOUS_RECTIFICATION_BALANCED_MOD,  /*!< complementary modulation with synchronous rectification  */
  PWM_BC_MOD_MAX
}PWM_BC_MODULATIONTYPE_t;

/**
 * Compare register update flag
 */
typedef enum PWM_BC_COMPAREFLAG
{
  PWM_BC_COMPARE_ZERO,               /*!<update compare register with value 0. Duty cycle is 100% */
  PWM_BC_COMPARE_PERIOD,             /*!<update compare register with value (period +1). Duty cycle is 0% */
  PWM_BC_COMPARE_DUTY,               /*!<update compare register with value direct duty. Duty cycle is ((period - duty)/period)% */
  PWM_BC_COMPARE_INVERSE_DUTY        /*!<update compare register with value (period - duty). Duty cycle is ((duty)/period)% */
}PWM_BC_COMPAREFLAG_t;


/**
 * inverter enable pin configurations
 */
typedef enum PWM_BC_INVERTERPINLEVEL
{
  PWM_BC_IPIN_NOTREQUIRED,           /*!<Inverter pin not required.*/
  PWM_BC_IPIN_HIGH,                  /*!<Inverter pin is active high.*/
  PWM_BC_IPIN_LOW                    /*!<Inverter pin is active low.*/
}PWM_BC_INVERTERPINLEVEL_t;


/**
 * State of the APP
 */

typedef enum PWM_BC_STATE
{
  PWM_BC_UNINITIALIZED,              /*!<default state after power on reset.
                                      APP goes to UNINITIALIZED state after execution of the Deinit function.*/
  PWM_BC_INITIALIZED,                /*!<APP is in INITIALIZED state after execution of the Init function*/
  PWM_BC_RUNNING,                    /*!<APP is in RUNNING state after execution of the Start function.*/
  PWM_BC_STOPPED                     /*!<APP is in STOPPED state after execution of the Stop function.*/
}PWM_BC_STATE_t;

/**
 * Direction of rotation
 */
typedef enum PWM_BC_Direction
{
  PWM_BC_CLOCKWISE = 0,                /*!<Clockwise direction */
  PWM_BC_ANTICLOCKWISE = 8             /*!<Anti-clockwise direction*/
}PWM_BC_Direction_t;
/**
 * Status of the APP which can be occured during initialization.
 */
typedef enum PWM_BC_STATUS
{
  PWM_BC_STATUS_SUCCESS,              /*!< APP status ok*/
  PWM_BC_STATUS_FAILURE,              /*!< APP status failure*/
  PWM_BC_INVALID_PARAM,               /*!< Input parameter is out of range.*/
  PWM_BC_OPERATION_NOT_ALLOWED        /*!< Operation is not allowed in the current state of the APP */
} PWM_BC_STATUS_t;
 
/**
 * @}
 */

/**********************************************************************************************************************
* DATA STRUCTURES
**********************************************************************************************************************/
/**
  * @ingroup PWM_BC_datastructures
  * @{
  */
/**
 * GPIO Port and Pin
 */
typedef struct PWM_BC_GPIO
{
  XMC_GPIO_PORT_t *const port;      /**< Port */
  const uint8_t pin;                /**< Pin */
} PWM_BC_GPIO_t;

/**
 *  CCU8-CC8 slice identifier data
 */
typedef struct PWM_BC_SLICE
{
  XMC_CCU8_SLICE_t  *slice_ptr;     /**< CCU8 CC8 pointer */
  uint8_t            slice_number;  /**< The slice identifier - 0 index based*/
} PWM_BC_SLICE_t;
/**
 * This structure holds the GUI configurable parameters of this APP.
 */
typedef struct PWM_BC_Config
{
  uint32_t                               ph_mcpatt_compmask[3];  /*!< multi-channel pattern used for comparison whether
                                                                      high side or low side switch is ON*/
  uint32_t                               ph_bothside_compmask[3];/*!< multi-channel pattern used for comparison whether
                                                                      high side or low side switch is ON*/
  uint32_t                               module_freq;            /*!< Represents module frequency*/
  uint32_t                               syncstart_mask;         /*!< Synchronous start mask as per CCU8 slices allocated*/
  uint32_t                               event_sr_selector[3];   /*!< mask for the SRS register*/
  uint32_t                               frequency_max;          /*!< Max period value*/
  uint32_t                               frequency_min;          /*!< Min period value*/
  PWM_BC_INVERTERPINLEVEL_t              inverter_pin;           /*!< This saves the inverter pin level*/
  XMC_CCU8_SLICE_COMPARE_CHANNEL_t       phu_cmpch;              /*!< Phase U compare channel */
  XMC_CCU8_SLICE_COMPARE_CHANNEL_t       phv_cmpch;              /*!< Phase V compare channel */
  XMC_CCU8_SLICE_COMPARE_CHANNEL_t       phw_cmpch;              /*!< Phase W compare channel */
  XMC_CCU8_SLICE_TRAP_EXIT_MODE_t        trap_exit_mode;         /*!< This tells the exit mode of trap*/
  uint16_t                               openloop_mc_pattern[16];/*!< Open loop multi channel pattern */
  uint16_t                               shadowtransfer_mask;    /*!< Shadow transfer mask as per CCU8 slices allocated*/
  uint8_t                                trap_sync_pwm;          /*!< This tells whether trap event should be
                                                                      synchronized with pwm or not*/
  uint8_t                                deadtime_control[3];    /*!< Mask for dead time feature for each phase */
  uint8_t                                trap_enable;            /*!< This enables/disables trap*/
  uint8_t                                syncstart_enable;       /*!< This enables/disables synchronous start of ccu8 slices*/
  uint8_t                                trap_hwsel;             /*!< HW_SEL mux for trap pin */
  uint8_t                                phase_u_out0;           /*!< This saves cc8 compare channel output number*/
  uint8_t                                phase_v_out0;           /*!< This saves cc8 compare channel output number*/
  uint8_t                                phase_w_out0;           /*!< This saves cc8 compare channel output number*/
  uint8_t                                ext_trigger;            /*!< external trigger enable for current measurement.*/
  uint8_t                                enable_permatchevent;   /*!< This tells whether to enable period match interrupt*/
  uint8_t                                enable_trapevent;       /*!< This tells whether to enable trap interrupt */
}PWM_BC_Config_t;

/**
  * This structure holds the BC parameters which change at run
  * time.
  */
typedef struct PWM_BC
{
  XMC_CCU8_MODULE_t*                         const  module_ptr;           /*!< CCU8 module initialization structure pointer*/
  const  PWM_BC_SLICE_t*                     const  phase_ptr[3];         /*!< Pointer to ccu8 phase timer init configuration
                                                                           structure*/
         XMC_POSIF_t*                        const  posif_module_ptr;     /*!< Pointer to posif module*/
  const  XMC_POSIF_MCM_CONFIG_t*             const  posif_mcmconf_ptr;    /*!< Pointer to posif mcm configuration structure*/
         GLOBAL_POSIF_t*                     const  global_posif_ptr;      /*!< pointer to the GLOBAL_POSIF APP handle
                                                                           structure */
         GLOBAL_CCU8_t*                       const  globalccu8_ptr;       /*!< pointer to the GLOBAL_CCU8 APP handle
                                                                           structure */
  const  XMC_CCU8_SLICE_COMPARE_CONFIG_t*    const  ph_timerinit_ptr;     /*!< CCU8 timer init structure pointer */
  const  XMC_CCU8_SLICE_EVENT_CONFIG_t*      const  startconfig_ptr;      /*!< Pointer to start event configuration
                                                                           structure*/
  const  XMC_CCU8_SLICE_EVENT_CONFIG_t*      const  trapconfig_ptr;       /*!< Pointer to trap event configuration
                                                                           structure*/
  const  PWM_BC_GPIO_t*                      const  pwmoutpin_ptr[6];     /*!< GPIO pin initialization structure pointer for
                                                                           PWM op pins */
  const  XMC_GPIO_CONFIG_t*                  const  pwmoutconfig_ptr[6];  /*!< GPIO pin configuration structure pointer for
                                                                           PWM op pins */
  const  PWM_BC_GPIO_t*                      const  trapinpin_ptr;        /*!< GPIO pin initialization structure pointer for
                                                                           trap input pin */
  const  XMC_GPIO_CONFIG_t*                  const  trapinconfig_ptr;     /*!< GPIO pin configuration structure pointer for
                                                                           trap input pin */
  const  PWM_BC_GPIO_t*                      const  inverterpin_ptr;      /*!< GPIO pin initialization structure pointer for
                                                                           inverter enable pin */
  const  XMC_GPIO_CONFIG_t*                  const  inverterpinconfig_ptr;/*!< GPIO pin configuration structure pointer for
                                                                           inverter enable pin */
  const  PWM_BC_Config_t*                    const  config_ptr;           /*!< pointer to the Dynamic Handle of the APP */
         XMC_CCU8_SLICE_DEAD_TIME_CONFIG_t*  const  deadtimeconfig_ptr;   /*!< Pointer to Dead time configuration structure*/
         PWM_BC_STATE_t                             state;                /*!< State of the APP */
         PWM_BC_Direction_t                         direction;            /*!< Direction of the rotation*/
         PWM_BC_MODULATIONTYPE_t                    modulation_type;      /*!< PWM modulation type */
         PWM_BC_COMPAREFLAG_t                       ph_cmpflag[3];        /*!< control flag for compare value update */
         uint16_t                                   period;               /*!< This variable gives the period value*/
         uint16_t                                   ph_cmpval[4];         /*!< Compare value for Phase U*/
         uint16_t                                   mc_pattern[4][16];    /*!< Multi-channel commutation pattern array for all
                                                                             modulation types*/
         uint8_t                                    deadtime_div;           /*!< Deadtime prescaler value*/
         uint8_t                                    dead_time_rising_edge;  /*!< Deadtime register value*/
         uint8_t                                    dead_time_falling_edge; /*!< Deadtime register value*/
}PWM_BC_t;

/**
 * @}
 */

#ifdef __cplusplus
extern "C" {
#endif
/**
 * @ingroup PWM_BC_apidoc
 * @{
 */
  /***********************************************************************************************************************
   * API Prototypes
   **********************************************************************************************************************/
/**
 * @brief Get PWM_BC APP version
 * @return DAVE_APP_VERSION_t APP version information (major, minor and patch number)
 *
 * \par<b>Description: </b><br>
 * The function can be used to check application software compatibility with a
 * specific version of the APP.
 *
 * Example Usage:
 *
 * @code
 * #include <DAVE.h>
 *
 * int main(void) {
 *   DAVE_STATUS_t init_status;
 *   DAVE_APP_VERSION_t version;
 *
 *   // Initialize PWM_BC APP:
 *   // PWM_BC_Init() is called from within DAVE_Init().
 *   init_status = DAVE_Init();
 *
 *   version = PWM_BC_GetAppVersion();
 *   if (version.major != 1U) {
 *     // Probably, not the right version.
 *   }
 *
 *   // More code here
 *   while(1) {
 *
 *   }
 *   return (0);
 * }
 * @endcode<BR>
 */

DAVE_APP_VERSION_t PWM_BC_GetAppVersion(void);
/**
 * @brief Initializes APP with configuration associated with APP struture through HandlePtr.
 * @param HandlePtr Pointer of the APP user configuration
 * @return @ref PWM_BC_STATUS_t It returns PWM_BC_STATUS_FAILURE when any of the consumed low level APP \n
 * init function is getting failed<BR>
 * \par<b>Description:</b><br>
 *  Initializes APP with configuration associated with APP struture through HandlePtr. \n
 *  It is the first function to be called to invoke this APP.<br>
 *  Initializes CCU8 module and POSIF module using respective low level driver init functions.\n
 * Example Usage:
 * @code
   #include <DAVE.h>
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 *  PWM_BC_Start()<br>
 */
PWM_BC_STATUS_t PWM_BC_Init(PWM_BC_t* HandlePtr);
/**
 * @brief Starts the APP and initiates the synchronous start for
 * the CC8 slices.
 * @param HandlePtr Pointer of the APP user configuration \n
 * @return None\n<BR>
 * \par<b>Description:</b><br>
 *  Function starts the APP by trigger CCU8 slices used to generate PWM for block commutation.\n
 *  PWM_BC_Init() function should get called before calling this API <br>
 *  Function executed only when APP state is PWM_BC_INITIALIZED or when APP state is
 *  PWM_BC_STOPPED.\n
 * Example Usage:
 * @code
   #include <DAVE.h>
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 *  PWM_BC_DutyCycleUpdate()<br>
 *  PWM_BC_Stop()<br>
 */
void PWM_BC_Start(PWM_BC_t* HandlePtr);
/**
 * @brief Stops the APP by stopping the
 * PWM generation. It also resets the inverter enable pin.
 * @param HandlePtr Pointer of the APP user configuration \n
 * @return None\n<BR>
 * \par<b>Description:</b><br>
 *  Function stops the CCU8 slices used to generate PWM for block commutation and
    resets the inverter enable pin level, executing the function changes the APP state to PWM_BC_RUNNING .\n
 *  Calling this api will not have any effect if pwm is not running.\n
 *
 * Example Usage:
 * @code
   #include <DAVE.h>
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     //Do something
     while(1)
     {
       if(XMC_CCU8_SLICE_GetEvent(PWM_BC_0.phase_ptr[0]->slice_ptr,XMC_CCU8_SLICE_IRQ_ID_TRAP) == 1)
       {
         //motor stop is called when trap occurs
         //trap should be enabled in the gui.
         PWM_BC_Stop((PWM_BC_t*)&PWM_BC_0);
       }
     }
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 *  PWM_BC_Start()<br>
 */
void PWM_BC_Stop(PWM_BC_t* HandlePtr);

/**
 * @brief Calculates the compare values based on modulation type.
 * @param HandlePtr Handle of the PWM_BC APP
 * @return void
 * <BR>
 *
 * \par<b>Description:</b><br>
 * Based upon modulation type and modulation pattern, this API calculates the 
 * compare values for three phases - The calculated compare value can be zero percent duty cycle,100% duty or
 * actual duty based upon the current multichannel pattern and modulation techniques.\n
 * This API should be used along with PWM_BC_SetNextMCPatt(). <br>
 * It can be called when immediate multichannel pattern transfer is done or synchronous rectification (balanced)
 * modulation type is selected. <br>
 * Example Usage:
 * @code
   #include <DAVE.h>
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     //Do something

     while(1);
     return 0;
   }
    //enable period match in event settings tab
   //Drag one interrupt APP configure with below handler name
   //connect  period match signal to interrupt
   void PeriodMatchInterruptHandler(void)
   {
     static uint32_t index = 1;
     if(index > 6)
     {
       index = 1;
     }
     else
     {
      index++;
     }
     PWM_BC_DutyCycleUpdate((PWM_BC_t*)&PWM_BC_0,500);
     PWM_BC_SetNextMCPatt((PWM_BC_t*)&PWM_BC_0,index);
     XMC_POSIF_MCM_UpdateMultiChannelPattern(PWM_BC_0.posif_module_ptr); //immediate transfer
     PWM_BC_ModulationForImmedTransfer((PWM_BC_t*)&PWM_BC_0);
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_SetNextMCPatt()
 * PWM_BC_ModulationForSyncTransfer()
 */
void PWM_BC_ModulationForImmedTransfer(PWM_BC_t* HandlePtr);

/**
 * @brief Calculates the compare values based on modulation type.
 * @param HandlePtr Handle of the PWM_BC APP
 * @return void
 * <BR>
 *
 * \par<b>Description:</b><br>
 * Based upon modulation type and modulation pattern, this API calculates the
 * compare values for three phases - The calculated compare value can be zero percent duty cycle,100% duty or
 * actual duty based upon the expected multichannel pattern and modulation techniques.\n
 * This API should be used along with PWM_BC_SetNextMCPatt(). <br>
 * It can be called when multichannel pattern transfer is sync with PWM.<br>
 * Example Usage:
 * @code
   #include <DAVE.h>
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     //Do something

     while(1);
     return 0;
   }
    //enable period match in event settings tab
   //Drag one interrupt APP configure with below handler name
   //connect  period match signal to interrupt
   void PeriodMatchInterruptHandler(void)
   {
     static uint32_t index = 1;
     if(index > 6)
     {
       index = 1;
     }
     else
     {
      index++;
     }
     PWM_BC_DutyCycleUpdate((PWM_BC_t*)&PWM_BC_0,500);
     PWM_BC_SetNextMCPatt((PWM_BC_t*)&PWM_BC_0,index);
     PWM_BC_ModulationForSyncTransfer((PWM_BC_t*)&PWM_BC_0);
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_SetNextMCPatt()
 * PWM_BC_ModulationForImmedTransfer()
 */
void PWM_BC_ModulationForSyncTransfer(PWM_BC_t* HandlePtr);
/**
 * @brief Updates the duty cycle of phase U, V, W.
 * @param HandlePtr Pointer of the APP user configuration\n
 * @param dutycycle User desired duty cycle, dutycycle value
 * should be in terms of ccu8 count and should be in range of
 * 0 to period value \n
 * @return None<BR>
 * \par<b>Description:</b><br>
 * Requested Duty cycle is applied to the phases based on modulation type and pattern.
 * e.g In high side modulation, modulated output is applied to the high side switch <br>
 * (direct output of the compare channel - with given duty cycle)
 * and high output is applied to the low side switch <br>
 * (inverted output of the compare channel with 0% duty cycle) when respective switches are active.<br>
 * Example Usage:
 * @code
   #include <DAVE.h>
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     //Do something

     while(1);
     return 0;
   }
    //enable period match in event settings tab
   //Drag one interrupt APP configure with below handler name
   //connect  period match signal to interrupt
   void PeriodMatchInterruptHandler(void)
   {
     PWM_BC_DutyCycleUpdate((PWM_BC_t*)&PWM_BC_0,500);

   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_ModulationForImmedTransfer()
 * PWM_BC_ModulationForSyncTransfer()
 */

void PWM_BC_DutyCycleUpdate(PWM_BC_t* HandlePtr, uint16_t dutycycle);
/**
 * @brief Changes the modulation type dynamically.
 * @param HandlePtr Pointer of the APP user configuration \n
 * @param modtype desired modulation type of @ref PWM_BC_MODULATIONTYPE_t type \n
 * @return @ref PWM_BC_STATUS_t will return state PWM_BC_INVALID_PARAM if modtype is equal to/greater than
 * PWM_BC_MOD_MAX\n<BR>
 * \par<b>Description:</b><br>
 * Function to change the PWM modulation type for Block Commutation algorithm.
 * modulation type can be changed at run time and respective multi-channel pattern will
 * get applied.<br>
 * Care should be taken in user code that when user is switching to synchronous rectification (balanced)
 * mode . after setting next multichannel pattern it is required to call
 * PWM_BC_ModulationForImmedTransfer()  for compare value update
 * instead of calling PWM_BC_ModulationForSyncTransfer()/PWM_BC_ModulationForImmedTransfer() for other
 * modulation type\n
 * Example Usage:
 * @code
   #include <DAVE.h>
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     //Do something
     PWM_BC_SetModulationType((PWM_BC_t*)&PWM_BC_0,PWM_BC_SYNCHRONOUS_RECTIFICATION_BALANCED_MOD);
     if(status == DAVE_STATUS_FAILURE)
     {
       //do something
     }
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_ModulationForImmedTransfer()
 * PWM_BC_ModulationForSyncTransfer()
 * PWM_BC_GetModulationType()
 */
PWM_BC_STATUS_t PWM_BC_SetModulationType
(
  PWM_BC_t* HandlePtr,
  PWM_BC_MODULATIONTYPE_t modtype
);
/**
 * @brief Reads the modulation type.
 * @param HandlePtr Pointer of the APP user configuration\n
 * @return @ref PWM_BC_MODULATIONTYPE_t modulation type\n<BR>
 * \par<b>Description:</b><br>
 * Function returns the configured modulation type \n
 * API can be called at any point of time.<br>
 * Example Usage:
 * @code
   #include <DAVE.h>
   PWM_BC_MODULATIONTYPE_t mod_type;
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     //Do something
     mod_type = PWM_BC_GetModulationType((PWM_BC_t*)&PWM_BC_0);
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_ModulationForImmedTransfer()
 * PWM_BC_ModulationForSyncTransfer()
 * PWM_BC_SetModulationType()
 */
PWM_BC_MODULATIONTYPE_t PWM_BC_GetModulationType
(
  PWM_BC_t* const HandlePtr
);
/**
 * @brief Changes the direction of multichannel pattern.
 * @param HandlePtr Pointer of the APP user configuration
 * @param dir desired direction of @ref PWM_BC_Direction_t type
 * @return PWM_BC_STATUS_t will return state PWM_BC_STATUS_SUCCESS if user configures
 * PWM_BC_CLOCKWISE or PWM_BC_ANTICLOCKWISE\n<BR>
 * \par<b>Description:</b><br>
 * Function to change the direction of multichannel pattern based on clockwise or anti-clockwise
 * direction. \n
 * Example Usage:
 * @code
   #include <DAVE.h>
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     status |= (DAVE_STATUS_t)PWM_BC_SetDirection((PWM_BC_t*)&PWM_BC_0,PWM_BC_CLOCKWISE);
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     //Do something
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_GetDirection()
 */
PWM_BC_STATUS_t PWM_BC_SetDirection
(
  PWM_BC_t* HandlePtr,
  PWM_BC_Direction_t dir
);
/**
 * @brief Reads the direction of rotation.
 * @param HandlePtr Pointer of the APP user configuration\n
 * @return uint8_t returns the direction of motor
 * PWM_BC_CLOCKWISE -> 0 or PWM_BC_ANTICLOCKWISE -> 8\n<BR>
 * \par<b>Description:</b><br>
 * Function returns the direction of multichannel pattern either clockwise or anti-clockwise
 * direction input.\n The direction of multichannel pattern is direction of motor.
 * API can be called any point of time. <br>
 * Example Usage:
 * @code
   #include <DAVE.h>
   uint8_t dir;
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     dir = PWM_BC_GetDirection((PWM_BC_t*)&PWM_BC_0);
     if(status == DAVE_STATUS_FAILURE)
     {
       //do something
     }
     //Do something
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_SetDirection()
 */
uint8_t PWM_BC_GetDirection
(
  PWM_BC_t* HandlePtr
);
/**
 * @brief Updates the next multi-channel pattern.
 * @param HandlePtr Pointer of the APP user configuration \n
 * @param Index Represents index of multichannel pattern table \n
 * index value can vary from 1 to 6 count.
 * @return void <br>
 * \par<b>Description:</b><br>
 * Function updates next multichannel pattern into posif MCM shadow register
 * The updated shadow pattern can be transfered to actual MCM register, sychronous to PWM or
 * immediately \n
 * Followed by calling this function user should call PWM_BC_ModulationForImmedTransfer/PWM_BC_ModulationForSyncTransfer
 * function based on selected modulation technique and mode of multichannel pattern transfer for compare value update.<br>
 * For eg. \n
 * PWM_BC_ModulationForImmedTransfer() is called when multichannel pattern is transfered immediately or synchronous
 * rectification balanced is selected.\n
 * PWM_BC_ModulationForSyncTransfer() is called when multichannel pattern is transfered in sync with PWM \n
 * Example Usage:
 * @code
   #include <DAVE.h>
   uint8_t index = 1;
   uint32_t i = 0;
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);

     //Do something
     while(1)
     {
      for(i=0;i<=1000;i++)
      {
        //delay
      }
      if(index > 6)
      {
       index = 1;
      }
      else
      {
       index++;
      }
      PWM_BC_SetNextMCPatt((PWM_BC_t*)&PWM_BC_0,index);
      //Immediate Shadow transfer
      XMC_POSIF_MCM_UpdateMultiChannelPattern(PWM_BC_0.posif_module_ptr);
      PWM_BC_ModulationForImmedTransfer(&PWM_BC_0);
     }
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 */
void PWM_BC_SetNextMCPatt(PWM_BC_t* const HandlePtr, uint8_t Index);
/**
 * @brief Updates the PWM frequency dynamically.
 * @param HandlePtr Pointer of the APP user configuration
 * @param Frequency Input frequency in terms of Hz
 * @return @ref PWM_BC_STATUS_t returns PWM_BC_INVALID_PARAM if configure frequency when APP state is\n
 * PWM_BC_STATUS_RUNNING
 * \par<b>Description:</b><br>
 * Function configures the PWM frequency.
 * It can configure frequency only when APP state is not PWM_BC_STATUS_RUNNING \n
 * Example Usage:
 * @code
   #include <DAVE.h>
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     status |= (DAVE_STATUS_t)PWM_BC_SetPWMFrequency((PWM_BC_t*)&PWM_BC_0,10000);
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     //Do something
     if(status == DAVE_STATUS_FAILURE)
     {
       //do something
     }
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_GetPWMFrequency()
 */
PWM_BC_STATUS_t PWM_BC_SetPWMFrequency(PWM_BC_t* HandlePtr, uint32_t Frequency);

/**
 * @brief Reads the PWM frequency.
 * @param HandlePtr Pointer of the APP user configuration \n
 * @return uint32_t Returns PWM frequency in Hz
 * \par<b>Description:</b><br>
 * Function returns the PWM frequency in terms of hertz. \n
 * API can be called at any point of time.<br>
 * Example Usage:
 * @code
   #include <DAVE.h>
   uint32_t frequency;
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     frequency = PWM_BC_GetPWMFrequency((PWM_BC_t*)&PWM_BC_0); //will return configured frequency
     //Do something
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_SetPWMFrequency()
 */
uint32_t PWM_BC_GetPWMFrequency(PWM_BC_t* const HandlePtr);
/**
 * @brief Updates the PWM rising and falling edge dead time dynamically.
 * @param HandlePtr Pointer of the APP user configuration
 * @param DeadTimeRisingEdge - Desired rising edge deadtime value in nanoseconds
 * @param DeadTimeFallingEdge - Desired falling edge deadtime value in nanoseconds
 * @return @ref PWM_BC_STATUS_t returns PWM_BC_STATUS_SUCCESS only when configured deadtime are
 * within the limits \n
 * \par<b>Description:</b><br>
 * Function configures the PWM rising and falling edge dead time dynamically \n
 * Function can be called at any point of time, the api will set the deadtime for
 * all three phases. <br>
 * Example Usage:
 * @code
   #include <DAVE.h>
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     status |= (DAVE_STATUS_t)PWM_BC_SetDeadTime((PWM_BC_t*)&PWM_BC_0,1000,1000);
     //Do something
     if(status == DAVE_STATUS_FAILURE)
     {
       //do something
     }
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_GetRisingEdgeDeadTime()
 * PWM_BC_GetFallingEdgeDeadTime()
 */

PWM_BC_STATUS_t PWM_BC_SetDeadTime(PWM_BC_t* HandlePtr, uint32_t DeadTimeRisingEdge,uint32_t DeadTimeFallingEdge);
/**
 * @brief Returns the current rising edge deadtime.
 * @param HandlePtr Pointer of the APP user configuration \n
 * @return uint32_t returns rising edge deadtime in nano seconds
 * \par<b>Description:</b><br>
 * Function returns the dead time for rising edge of PWM out in terms of nano seconds \n
 * Function can be called at any point of time. <br>
 * Example Usage:
 * @code
   #include <DAVE.h>
   uint32_t dead_time_rising_edge;
   int main (void)
   {
     DAVE_STATUS_t status;
     uint32_t dead_time_rising_edge;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     //Do something
     dead_time_rising_edge = PWM_BC_GetRisingEdgeDeadTime((PWM_BC_t*)&PWM_BC_0);
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_SetDeadTime()
 */
uint32_t PWM_BC_GetRisingEdgeDeadTime(PWM_BC_t* const HandlePtr);

/**
 * @brief Returns the configured falling edge deadtime.
 * @param HandlePtr Pointer of the APP user configuration\n
 * @return uint32_t returns falling edge deadtime in nano seconds
 * \par<b>Description:</b><br>
 * Function returns the dead time for falling edge of PWM out in terms of nano seconds \n
 * Function can be called at any point of time. <br>
 * Example Usage:
 * @code
   #include <DAVE.h>
   uint32_t dead_time_falling_edge;
   int main (void)
   {
     DAVE_STATUS_t status;
     uint32_t dead_time_rising_edge;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     //Do something
     dead_time_falling_edge = PWM_BC_GetFallingEdgeDeadTime((PWM_BC_t*)&PWM_BC_0);
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_SetDeadTime()
 */
uint32_t PWM_BC_GetFallingEdgeDeadTime(PWM_BC_t* const HandlePtr);

/**
 * @brief Disables the inverter enable pin.
 * @param HandlePtr Pointer of the APP user configuration\n
 * @return void
 * \par<b>Description:</b><br>
 * Function disables inverter pin if applicable \n
 * Calling this api sets or resets the inverter enable pin based on active level
 * configuration.<br>
 * calling this function will not have any effect if inverter enable pin configuration
 * is set to disabled in GUI. <br>
 * Example Usage:
 * @code
   #include <DAVE.h>
   uint32_t dead_time_falling_edge;
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     // In the below scenario when inverter disable is called, it disables
     // the inverter pin but PWM will keep on generating.
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     //Do something
     PWM_BC_InverterDisable((PWM_BC_t*)&PWM_BC_0);
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_InverterEnable()
 */
void PWM_BC_InverterDisable(PWM_BC_t* const HandlePtr);
/**
 * @brief Enables the inverter enable pin.
 * @param HandlePtr Pointer of the APP user configuration\n
 * @return void
 * \par<b>Description:</b><br>
 * Function enables inverter pin if applicable \n
 * Calling this api sets or resets the inverter enable pin based on active level
 * configuration.<br>
 * calling this function will not have any effect if inverter enable pin configuration
 * is set to disabled in GUI. <br>
 * Example Usage:
 * @code
   #include <DAVE.h>
   uint32_t dead_time_falling_edge;
   int main (void)
   {
     DAVE_STATUS_t status;
     status = DAVE_Init(); //PWM_BC_Init() called by DAVE_Init()
     PWM_BC_Start((PWM_BC_t*)&PWM_BC_0);
     //Do something
     PWM_BC_InverterDisable((PWM_BC_t*)&PWM_BC_0);
     //inverter alone is disabled but PWM is keep on running
     //Do something
     PWM_BC_InverterEnable((PWM_BC_t*)&PWM_BC_0); //Inverter is enabled
     while(1);
     return 0;
   }
 * @endcode
 * \par<b>Related APIs:</b><br>
 * PWM_BC_InverterDisable()
 */
void PWM_BC_InverterEnable(PWM_BC_t* const HandlePtr);

/*
 * @brief Calculates initial the compare values for Complementary_SyncRectification
 * modulation type.It is not recommended to call this function by user.
 * @param[in] HandlePtr Handle of the PWM_BC APP
 * @return void
 * <BR>
 * Details of function
 * This function calculates the compare values for three phases -
 * High output or Low output or Modulated output.\n
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
void PWM_BC_SyncModulation_SyncRecti_InitMod(PWM_BC_t* HandlePtr);
#include "PWM_BC_Extern.h"

/**
 * @}
 */
#ifdef __cplusplus
}
#endif

#endif /* PWM_BC_H_ */

