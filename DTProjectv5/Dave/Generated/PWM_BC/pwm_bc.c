/**
 * @file pwm_bc.c
 * @date 2015-10-08
  *
 * NOTE:
 * This file is generated by DAVE. Any manual modification done to this file will be lost when the code is regenerated.
 * @cond
 ***********************************************************************************************************************
 * PWM_BC v4.0.16 - Generates PWM for block commutation (trapezoidal) using CCU8 and POSIF module.
 *
 * Copyright (c) 2015-2017, Infineon Technologies AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,are permitted provided that the
 * following conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice, this list of conditions and the  following
 *   disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 *   following disclaimer in the documentation and/or other materials provided with the distribution.
 *
 *   Neither the name of the copyright holders nor the names of its contributors may be used to endorse or promote
 *   products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * To improve the quality of the software, users are encouraged to share modifications, enhancements or bug fixes
 * with Infineon Technologies AG (dave@infineon.com).
 ***********************************************************************************************************************
 *
 * Change History
 * --------------
 *
 * 2015-02-20:
 *     - Initial version
 *
 * 2015-06-20:
 *     - Sync start functionality updated
 *     - Period match interrupt is replaced with one match
 *
 * @endcond
 *
 */

/***********************************************************************************************************************
 * HEADER FILES
 **********************************************************************************************************************/
#include "pwm_bc.h"

/***********************************************************************************************************************
 * MACROS
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL DATA
 **********************************************************************************************************************/

/***********************************************************************************************************************
 * LOCAL ROUTINES
 **********************************************************************************************************************/
/**
 * @brief This function calculates the compare values for Complementary_SyncRectification
 * modulation type. 
 * @param[in] HandlePtr Handle of the PWM_BC App
 * @return void
 * <BR>
 * Details of function
 * This function calculates the compare values for three phases - 
 * High output or Low output or Modulated output.\n
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
void PWM_BC_lImmeModulation_SyncRecti(PWM_BC_t* HandlePtr);

/**
 * @brief This function initializes PWM output pins, trap pin and inverter
 * enable pin.
 * @param[in] HandlePtr Handle of the PWM_BC App
 * @return void
 * <BR>
 * <b>Reentrancy:  Yes</b><BR>
 * <b>Sync/Async:  Synchronous</b><BR>
 */
void PWM_BC_lPinInit(PWM_BC_t* const HandlePtr);


 
/**********************************************************************************************************************
* API IMPLEMENTATION
**********************************************************************************************************************/
/** Compare value calculation for Complementary_SyncRecti modulation type */
void PWM_BC_SyncModulation_SyncRecti_InitMod(PWM_BC_t* HandlePtr)
{
  uint8_t count,HighSideOn=0U;
  uint8_t BothSideModPhase=0U;
  uint16_t mcmval;
  XMC_ASSERT("PWM_BC_lImmeModulation_SyncRecti:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_HandleType_t *)NULL));

  mcmval = XMC_POSIF_MCM_GetMultiChannelPattern(HandlePtr->posif_module_ptr);
  for (count = (uint8_t)0; count < PWM_BC_MAXPHASE_COUNT; count++)
  {
    /*if both switches conducting */
    if (HandlePtr->config_ptr->ph_bothside_compmask[count] == 
                            (mcmval & (uint32_t)HandlePtr->config_ptr->ph_bothside_compmask[count]))
    {
        HandlePtr->ph_cmpflag[count] = PWM_BC_COMPARE_DUTY;
        XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[count]->slice_ptr,
                                         HandlePtr->config_ptr->deadtime_control[count]);
        BothSideModPhase =count;
    }
    /* if low side switch is conducting */
    else if ((HandlePtr->config_ptr->ph_mcpatt_compmask[count] << 1U) ==
        (mcmval & (uint32_t)(HandlePtr->config_ptr->ph_mcpatt_compmask[count] << 1U)))
    {
      HandlePtr->ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
       XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[count]->slice_ptr,(uint8_t)0);
    }
    /* if high side switch is conducting */
    else if (HandlePtr->config_ptr->ph_mcpatt_compmask[count] == 
                                                (mcmval & (uint32_t)(HandlePtr->config_ptr->ph_mcpatt_compmask[count])))
    {
      HandlePtr->ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
      HighSideOn =1U;
      XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[count]->slice_ptr,(uint8_t)0);
    }
    else
    {
    }
  }
  if (HighSideOn==1U)
  {

      HandlePtr->ph_cmpflag[BothSideModPhase] = PWM_BC_COMPARE_PERIOD;
  }
}
void PWM_BC_lImmeModulation_SyncRecti(PWM_BC_t* HandlePtr)
{
  uint8_t count;
  uint16_t mcmval;
  uint8_t modulation[3], phase = 0U;
  XMC_ASSERT("PWM_BC_lImmeModulation_SyncRecti:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));
  mcmval = XMC_POSIF_MCM_GetMultiChannelPattern(HandlePtr->posif_module_ptr);
  for (count = (uint8_t)0; count < PWM_BC_MAXPHASE_COUNT; count++)
   {
     /*if both switches conducting */
     if (HandlePtr->config_ptr->ph_bothside_compmask[count] ==
                                                 (mcmval & (uint32_t)HandlePtr->config_ptr->ph_bothside_compmask[count]))
     {
         XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[count]->slice_ptr,HandlePtr->config_ptr->deadtime_control[count]);
         modulation[count]=3U;
     }
     /* if low side switch is conducting */
     else if ((HandlePtr->config_ptr->ph_mcpatt_compmask[count] << 1U) ==
         (mcmval & (uint32_t)(HandlePtr->config_ptr->ph_mcpatt_compmask[count] << 1U)))
     {
         modulation[count]=2U;
         phase =count+3U;
         HandlePtr->ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
         XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[count]->slice_ptr,(uint8_t)0);
     }
     /* if high side switch is conducting */
     else if (HandlePtr->config_ptr->ph_mcpatt_compmask[count] ==
                                                 (mcmval & (uint32_t)(HandlePtr->config_ptr->ph_mcpatt_compmask[count])))
     {
     modulation[count]=1U;
         phase =count;
         HandlePtr->ph_cmpflag[count] = PWM_BC_COMPARE_ZERO;
         XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[count]->slice_ptr,(uint8_t)0);
     }
     else
     {
         modulation[count]=0U;
         XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[count]->slice_ptr,HandlePtr->config_ptr->deadtime_control[count]);

     }
   }
  switch(phase)
  {
  case 0: /*Phase U High side ON*/
      if (modulation[1] ==3U) /*Phase V both side modulation*/
      {
          HandlePtr->ph_cmpflag[2] = PWM_BC_COMPARE_INVERSE_DUTY;
          HandlePtr->ph_cmpflag[1] = PWM_BC_COMPARE_DUTY;
      }
      else /*Phase W both side modulation*/
      {
          HandlePtr->ph_cmpflag[1] = PWM_BC_COMPARE_INVERSE_DUTY;
          HandlePtr->ph_cmpflag[2] = PWM_BC_COMPARE_DUTY;
      }
      break;

  case 1:/*Phase V High side ON*/
      if (modulation[2] ==3U)/*Phase W both side modulation*/
      {
          HandlePtr->ph_cmpflag[0] = PWM_BC_COMPARE_INVERSE_DUTY;
          HandlePtr->ph_cmpflag[2] = PWM_BC_COMPARE_DUTY;
      }
      else /*Phase U both side modulation*/
      {

          HandlePtr->ph_cmpflag[2] = PWM_BC_COMPARE_INVERSE_DUTY;
          HandlePtr->ph_cmpflag[0] = PWM_BC_COMPARE_DUTY;
      }
      break;

  case 2:/*Phase W High side ON*/
      if (modulation[0] == 3U) /*Phase U both side modulation*/
      {
          HandlePtr->ph_cmpflag[1] = PWM_BC_COMPARE_INVERSE_DUTY;
          HandlePtr->ph_cmpflag[0] = PWM_BC_COMPARE_DUTY;
      }
      else/*Phase V both side modulation*/
      {
          HandlePtr->ph_cmpflag[0] = PWM_BC_COMPARE_INVERSE_DUTY;
          HandlePtr->ph_cmpflag[1] = PWM_BC_COMPARE_DUTY;
      }
      break;

  case 3: /*Phase U Low side ON*/
      if (modulation[1] ==3U) /*Phase V both side modulation*/
      {
          HandlePtr->ph_cmpflag[2] = PWM_BC_COMPARE_DUTY;
          HandlePtr->ph_cmpflag[1] = PWM_BC_COMPARE_INVERSE_DUTY;
      }
      else /*Phase W both side modulation*/
      {
          HandlePtr->ph_cmpflag[1] = PWM_BC_COMPARE_DUTY;
          HandlePtr->ph_cmpflag[2] = PWM_BC_COMPARE_INVERSE_DUTY;
      }
      break;

  case 4:/*Phase V Low side ON*/
      if (modulation[2] ==3U) /*Phase W both side modulation*/
      {
          HandlePtr->ph_cmpflag[2] = PWM_BC_COMPARE_INVERSE_DUTY;
          HandlePtr->ph_cmpflag[0] = PWM_BC_COMPARE_DUTY;
      }
      else/*Phase U both side modulation*/
      {
          HandlePtr->ph_cmpflag[0] = PWM_BC_COMPARE_INVERSE_DUTY;
          HandlePtr->ph_cmpflag[2] = PWM_BC_COMPARE_DUTY;
      }
      break;

  case 5:/*Phase W Low side ON*/
      if (modulation[0] ==3U) /*Phase U both side modulation*/
      {
          HandlePtr->ph_cmpflag[0] = PWM_BC_COMPARE_INVERSE_DUTY;
          HandlePtr->ph_cmpflag[1] = PWM_BC_COMPARE_DUTY;
      }
      else /*Phase V both side modulation*/
      {
          HandlePtr->ph_cmpflag[1] = PWM_BC_COMPARE_INVERSE_DUTY;
          HandlePtr->ph_cmpflag[0] = PWM_BC_COMPARE_DUTY;
      }
      break;
  default:
      break;
  }
}

/* Initialization of the GPIO */
void PWM_BC_lPinInit(PWM_BC_t* const HandlePtr)
{
  XMC_ASSERT("PWM_BC_lPinInit:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));
  XMC_GPIO_Init(HandlePtr->pwmoutpin_ptr[0]->port,HandlePtr->pwmoutpin_ptr[0]->pin, HandlePtr->pwmoutconfig_ptr[0]);
  XMC_GPIO_Init(HandlePtr->pwmoutpin_ptr[1]->port,HandlePtr->pwmoutpin_ptr[1]->pin, HandlePtr->pwmoutconfig_ptr[1]);
  XMC_GPIO_Init(HandlePtr->pwmoutpin_ptr[2]->port,HandlePtr->pwmoutpin_ptr[2]->pin, HandlePtr->pwmoutconfig_ptr[2]);
  XMC_GPIO_Init(HandlePtr->pwmoutpin_ptr[3]->port,HandlePtr->pwmoutpin_ptr[3]->pin, HandlePtr->pwmoutconfig_ptr[3]);
  XMC_GPIO_Init(HandlePtr->pwmoutpin_ptr[4]->port,HandlePtr->pwmoutpin_ptr[4]->pin, HandlePtr->pwmoutconfig_ptr[4]);
  XMC_GPIO_Init(HandlePtr->pwmoutpin_ptr[5]->port,HandlePtr->pwmoutpin_ptr[5]->pin, HandlePtr->pwmoutconfig_ptr[5]);

  if (NULL != HandlePtr->trapinpin_ptr)
  {
    XMC_GPIO_Init(HandlePtr->trapinpin_ptr->port,HandlePtr->trapinpin_ptr->pin,HandlePtr->trapinconfig_ptr);
    XMC_GPIO_SetHardwareControl(HandlePtr->trapinpin_ptr->port,HandlePtr->trapinpin_ptr->pin,
                                  (XMC_GPIO_HWCTRL_t)HandlePtr->config_ptr->trap_hwsel);
  }
  /*Inverter Enable pin settings.*/
  if (PWM_BC_IPIN_HIGH == HandlePtr->config_ptr->inverter_pin)
  {
    XMC_GPIO_Init(HandlePtr->inverterpin_ptr->port,HandlePtr->inverterpin_ptr->pin, HandlePtr->inverterpinconfig_ptr);
    XMC_GPIO_SetOutputLow(HandlePtr->inverterpin_ptr->port,HandlePtr->inverterpin_ptr->pin);
  }
  if (PWM_BC_IPIN_LOW == HandlePtr->config_ptr->inverter_pin)
  {
    XMC_GPIO_Init(HandlePtr->inverterpin_ptr->port,HandlePtr->inverterpin_ptr->pin,HandlePtr->inverterpinconfig_ptr);
    XMC_GPIO_SetOutputHigh(HandlePtr->inverterpin_ptr->port,HandlePtr->inverterpin_ptr->pin);
  }
}


/* App API to retrieve the App version info */
DAVE_APP_VERSION_t PWM_BC_GetAppVersion(void)
{
  DAVE_APP_VERSION_t version;

  version.major = PWM_BC_MAJOR_VERSION;
  version.minor = PWM_BC_MINOR_VERSION;
  version.patch = PWM_BC_PATCH_VERSION;

  return version;
}
/**
 * This function initializes all the three CCU8 phases and 
 * POSIF peripheral as per the user configurations
 */
PWM_BC_STATUS_t PWM_BC_Init(PWM_BC_t* HandlePtr)
{
  uint8_t index;
  uint32_t init_status = (uint32_t)PWM_BC_STATUS_SUCCESS;

  XMC_ASSERT("PWM_BC_Init:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));

  if (PWM_BC_UNINITIALIZED == HandlePtr->state)
  {
    /* CCU8 global init to start the prescalar and de-assert the module */
    init_status  = (uint32_t)GLOBAL_CCU8_Init(HandlePtr->globalccu8_ptr);

    /* POSIF global init*/
    init_status  |= (uint32_t)GLOBAL_POSIF_Init(HandlePtr->global_posif_ptr);
        
    PWM_BC_lPinInit(HandlePtr);
    init_status |= (uint32_t)XMC_POSIF_MCM_Init(HandlePtr->posif_module_ptr,HandlePtr->posif_mcmconf_ptr);

    if (init_status == (uint32_t)PWM_BC_STATUS_SUCCESS)
    {
      for (index = (uint8_t)0; index < PWM_BC_MAXPHASE_COUNT; index++)
      {
        /* Phase configurations */
        XMC_CCU8_SLICE_CompareInit(HandlePtr->phase_ptr[index]->slice_ptr, HandlePtr->ph_timerinit_ptr);
        /* Update period registers */
        XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[index]->slice_ptr,HandlePtr->period);
        /* configure a slice trigger event*/
        XMC_CCU8_SLICE_ConfigureEvent(HandlePtr->phase_ptr[index]->slice_ptr,(XMC_CCU8_SLICE_EVENT_t)XMC_CCU8_SLICE_EVENT_0,
                                         HandlePtr->startconfig_ptr);
        /* configure a slice trigger event*/
        XMC_CCU8_SLICE_ConfigureEvent(HandlePtr->phase_ptr[index]->slice_ptr,(XMC_CCU8_SLICE_EVENT_t)XMC_CCU8_SLICE_EVENT_2,
                                         HandlePtr->trapconfig_ptr);

        /* Phases - Connect events to node*/
        XMC_CCU8_SLICE_SetInterruptNode(HandlePtr->phase_ptr[index]->slice_ptr,
                      (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH,
                      (XMC_CCU8_SLICE_SR_ID_t)( HandlePtr->config_ptr->event_sr_selector[index] & (0x03U)));

        XMC_CCU8_SLICE_SetInterruptNode(HandlePtr->phase_ptr[index]->slice_ptr,
                      (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_1,
                      (XMC_CCU8_SLICE_SR_ID_t)((HandlePtr->config_ptr->event_sr_selector[index] >>
                      CCU8_CC8_SRS_CM1SR_Pos) & (0x03U)));

        XMC_CCU8_SLICE_SetInterruptNode(HandlePtr->phase_ptr[index]->slice_ptr,
                      (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_COMPARE_MATCH_UP_CH_2,
                      (XMC_CCU8_SLICE_SR_ID_t)((HandlePtr->config_ptr->event_sr_selector[index] >>
                      CCU8_CC8_SRS_CM2SR_Pos) & (0x03U)));

        XMC_CCU8_SLICE_SetInterruptNode(HandlePtr->phase_ptr[index]->slice_ptr, (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_EVENT0,
                      (XMC_CCU8_SLICE_SR_ID_t)((HandlePtr->config_ptr->event_sr_selector[index] >>
                      CCU8_CC8_SRS_E0SR_Pos) & (0x03U)));

        XMC_CCU8_SLICE_SetInterruptNode(HandlePtr->phase_ptr[index]->slice_ptr, (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_EVENT1,
                      (XMC_CCU8_SLICE_SR_ID_t)((HandlePtr->config_ptr->event_sr_selector[index] >>
                      CCU8_CC8_SRS_E1SR_Pos) & (0x03U)));

        XMC_CCU8_SLICE_SetInterruptNode(HandlePtr->phase_ptr[index]->slice_ptr, (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_EVENT2,
                      (XMC_CCU8_SLICE_SR_ID_t)((HandlePtr->config_ptr->event_sr_selector[index] >>
                      CCU8_CC8_SRS_E2SR_Pos) & (0x03U)));
      }

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr, HandlePtr->config_ptr->phu_cmpch, 0x00U);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr, HandlePtr->config_ptr->phv_cmpch, 0x00U);

      XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr, HandlePtr->config_ptr->phw_cmpch, 0x00U);



      /* Slice configuration for triggering ADC for current measurement */
      if (1U == HandlePtr->config_ptr->ext_trigger)
      {
        XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[2]->slice_ptr,(XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH);
        XMC_CCU8_SLICE_SetInterruptNode(HandlePtr->phase_ptr[2]->slice_ptr,
                 (XMC_CCU8_SLICE_IRQ_ID_t)XMC_CCU8_SLICE_IRQ_ID_PERIOD_MATCH,
                 (XMC_CCU8_SLICE_SR_ID_t)((HandlePtr->config_ptr->event_sr_selector[2]>> CCU8_CC8_SRS_POSR_Pos) & (0x03U)));
      }

      XMC_CCU8_EnableShadowTransfer(HandlePtr->module_ptr,(uint32_t)HandlePtr->config_ptr->shadowtransfer_mask);
      /* Enable period match interrupt */
      if (1U == HandlePtr->config_ptr->enable_permatchevent)
      {
        XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[0]->slice_ptr,XMC_CCU8_SLICE_IRQ_ID_ONE_MATCH);
      }
      /* Enable trap interrupt */
      if (1U == HandlePtr->config_ptr->enable_trapevent)
      {
        XMC_CCU8_SLICE_EnableEvent(HandlePtr->phase_ptr[0]->slice_ptr,XMC_CCU8_SLICE_IRQ_ID_EVENT2);
      }

      XMC_CCU8_EnableClock(HandlePtr->module_ptr,HandlePtr->phase_ptr[0]->slice_number);
      XMC_CCU8_EnableClock(HandlePtr->module_ptr,HandlePtr->phase_ptr[1]->slice_number);
      XMC_CCU8_EnableClock(HandlePtr->module_ptr,HandlePtr->phase_ptr[2]->slice_number);

      HandlePtr->dead_time_rising_edge     = (uint8_t)HandlePtr->deadtimeconfig_ptr->channel1_st_rising_edge_counter;
      HandlePtr->dead_time_falling_edge    = (uint8_t)HandlePtr->deadtimeconfig_ptr->channel1_st_falling_edge_counter;

      HandlePtr->deadtime_div  = (uint8_t)HandlePtr->deadtimeconfig_ptr->div;
      HandlePtr->state          = PWM_BC_INITIALIZED;
    }
    else
    {
      init_status = (uint32_t)PWM_BC_STATUS_FAILURE;
    }
  }
  return ((PWM_BC_STATUS_t)init_status);
}
/**
 * This function enables inverter.
 */
void PWM_BC_InverterEnable(PWM_BC_t* const HandlePtr)
{
  XMC_ASSERT("PWM_BC_InverterEnable:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));
              
  /*Inverter Enable pin settings.*/
  if (PWM_BC_IPIN_HIGH == HandlePtr->config_ptr->inverter_pin)
  {
    XMC_GPIO_SetOutputHigh(HandlePtr->inverterpin_ptr->port,HandlePtr->inverterpin_ptr->pin);
  }
  if (PWM_BC_IPIN_LOW == HandlePtr->config_ptr->inverter_pin)
  {
    XMC_GPIO_SetOutputLow(HandlePtr->inverterpin_ptr->port,HandlePtr->inverterpin_ptr->pin);
  }
}

/**
 * This function Disables inverter.
 */
void PWM_BC_InverterDisable(PWM_BC_t* const HandlePtr)
{
  XMC_ASSERT("PWM_BC_InverterDisable:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));
              
  /*Inverter Enable pin level is set to passive level.*/
  /*Inverter Enable pin settings.*/
  if (PWM_BC_IPIN_HIGH == HandlePtr->config_ptr->inverter_pin)
  {
    XMC_GPIO_SetOutputLow(HandlePtr->inverterpin_ptr->port,HandlePtr->inverterpin_ptr->pin);
  }
  if (PWM_BC_IPIN_LOW == HandlePtr->config_ptr->inverter_pin)
  {
    XMC_GPIO_SetOutputHigh(HandlePtr->inverterpin_ptr->port,HandlePtr->inverterpin_ptr->pin);
  }
}
/**
 * This function starts the CCU8 slices used to generate BC PWM.
 */
void PWM_BC_Start(PWM_BC_t* HandlePtr)
{
  uint8_t index;
  XMC_ASSERT("PWM_BC_Start:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));
  if ((PWM_BC_INITIALIZED == HandlePtr->state) ||
      (PWM_BC_STOPPED == HandlePtr->state))
  {
    PWM_BC_InverterEnable(HandlePtr);
    /* configure the Start trigger function of a slice*/
    XMC_CCU8_SLICE_StartConfig(HandlePtr->phase_ptr[0]->slice_ptr,XMC_CCU8_SLICE_EVENT_0,
                       XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
    XMC_CCU8_SLICE_StartConfig(HandlePtr->phase_ptr[1]->slice_ptr,XMC_CCU8_SLICE_EVENT_0,
                       XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
    XMC_CCU8_SLICE_StartConfig(HandlePtr->phase_ptr[2]->slice_ptr,XMC_CCU8_SLICE_EVENT_0,
                       XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);

    for (index = (uint8_t)0; index < PWM_BC_MAXPHASE_COUNT; index++)
    {
      XMC_CCU8_SLICE_ClearEvent(HandlePtr->phase_ptr[index]->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_EVENT2);
      XMC_CCU8_SLICE_ClearEvent(HandlePtr->phase_ptr[index]->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_TRAP);

      /* configure trap function*/
      XMC_CCU8_SLICE_TrapConfig(HandlePtr->phase_ptr[index]->slice_ptr,
                (XMC_CCU8_SLICE_TRAP_EXIT_MODE_t)HandlePtr->config_ptr->trap_exit_mode,
                (bool)HandlePtr->config_ptr->trap_sync_pwm);

      XMC_CCU8_SLICE_DeadTimeInit(HandlePtr->phase_ptr[index]->slice_ptr,HandlePtr->deadtimeconfig_ptr);
    }

    if ((uint8_t)1 == HandlePtr->config_ptr->trap_enable)
    {
      XMC_CCU8_SLICE_EnableTrap(HandlePtr->phase_ptr[0]->slice_ptr,
               ((uint32_t)HandlePtr->config_ptr->phase_u_out0 | ((uint32_t)HandlePtr->config_ptr->phase_u_out0 << 1U)));

      XMC_CCU8_SLICE_EnableTrap(HandlePtr->phase_ptr[1]->slice_ptr,
              ((uint32_t)HandlePtr->config_ptr->phase_v_out0 | ((uint32_t)HandlePtr->config_ptr->phase_v_out0 << 1U)));

      XMC_CCU8_SLICE_EnableTrap(HandlePtr->phase_ptr[2]->slice_ptr,
              ((uint32_t)HandlePtr->config_ptr->phase_w_out0 | ((uint32_t)HandlePtr->config_ptr->phase_w_out0 << 1U)));
    }

    /* Enable/disable dead time based on modulation type */
    if ((PWM_BC_SYNCHRONOUS_RECTIFICATION_MOD == HandlePtr->modulation_type) ||
        (PWM_BC_SYNCHRONOUS_RECTIFICATION_BALANCED_MOD == HandlePtr->modulation_type))
    {
      XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[0]->slice_ptr,HandlePtr->config_ptr->deadtime_control[0]);
      XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[1]->slice_ptr,HandlePtr->config_ptr->deadtime_control[1]);
      XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[2]->slice_ptr,HandlePtr->config_ptr->deadtime_control[2]);
    }
    else
    {
      XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[0]->slice_ptr,(uint8_t)0);
      XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[1]->slice_ptr,(uint8_t)0);
      XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[2]->slice_ptr,(uint8_t)0);
    }

    /* dynamic handle configurations*/
    if ((PWM_BC_LOWSIDE_MOD == HandlePtr->modulation_type))
    {
      HandlePtr->ph_cmpflag[0] = PWM_BC_COMPARE_PERIOD;
      HandlePtr->ph_cmpflag[1] = PWM_BC_COMPARE_PERIOD;
      HandlePtr->ph_cmpflag[2] = PWM_BC_COMPARE_PERIOD;
    }
    else
    {
      HandlePtr->ph_cmpflag[0] = PWM_BC_COMPARE_ZERO;
      HandlePtr->ph_cmpflag[1] = PWM_BC_COMPARE_ZERO;
      HandlePtr->ph_cmpflag[2] = PWM_BC_COMPARE_ZERO;
    }
    HandlePtr->ph_cmpval[0] = (uint16_t)0;
    HandlePtr->ph_cmpval[1] = HandlePtr->period + (uint16_t)1;
    if (1U == HandlePtr->config_ptr->syncstart_enable)
    {
      /** Start CCU8 slices synchronously */
      XMC_SCU_SetCcuTriggerHigh((uint32_t)HandlePtr->config_ptr->syncstart_mask);
      /* Disable the Start trigger function of a slice*/
      XMC_CCU8_SLICE_StartConfig(HandlePtr->phase_ptr[0]->slice_ptr,(XMC_CCU8_SLICE_EVENT_t)XMC_CCU8_SLICE_EVENT_NONE,
                         (XMC_CCU8_SLICE_START_MODE_t)XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
      XMC_CCU8_SLICE_StartConfig(HandlePtr->phase_ptr[1]->slice_ptr,(XMC_CCU8_SLICE_EVENT_t)XMC_CCU8_SLICE_EVENT_NONE,
                         (XMC_CCU8_SLICE_START_MODE_t)XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);
      XMC_CCU8_SLICE_StartConfig(HandlePtr->phase_ptr[2]->slice_ptr,(XMC_CCU8_SLICE_EVENT_t)XMC_CCU8_SLICE_EVENT_NONE,
                         (XMC_CCU8_SLICE_START_MODE_t)XMC_CCU8_SLICE_START_MODE_TIMER_START_CLEAR);

      /* disable synchronous start of CCU8 slices */
      XMC_SCU_SetCcuTriggerLow((uint32_t)HandlePtr->config_ptr->syncstart_mask);
    }
    /** Start posif*/
    XMC_POSIF_Start(HandlePtr->posif_module_ptr);
  
    HandlePtr->state = PWM_BC_RUNNING;
  }
}

/**
 * This function stops the CCU8 slices used to generate PWM.
 */
void PWM_BC_Stop(PWM_BC_t* HandlePtr)
{
  XMC_ASSERT("PWM_BC_Stop:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));
  /*Disable Inverter*/
  PWM_BC_InverterDisable(HandlePtr);

  if ((uint8_t)1 == HandlePtr->config_ptr->trap_enable)
  {
    XMC_CCU8_SLICE_DisableTrap(HandlePtr->phase_ptr[0]->slice_ptr,
             ((uint32_t)HandlePtr->config_ptr->phase_u_out0 | ((uint32_t)HandlePtr->config_ptr->phase_u_out0 << 1U)));

    XMC_CCU8_SLICE_DisableTrap(HandlePtr->phase_ptr[1]->slice_ptr,
            ((uint32_t)HandlePtr->config_ptr->phase_v_out0 | ((uint32_t)HandlePtr->config_ptr->phase_v_out0 << 1U)));

    XMC_CCU8_SLICE_DisableTrap(HandlePtr->phase_ptr[2]->slice_ptr,
            ((uint32_t)HandlePtr->config_ptr->phase_w_out0 | ((uint32_t)HandlePtr->config_ptr->phase_w_out0 << 1U)));
  }

  XMC_CCU8_SLICE_ClearEvent(HandlePtr->phase_ptr[0]->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_TRAP);
  XMC_CCU8_SLICE_ClearEvent(HandlePtr->phase_ptr[1]->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_TRAP);
  XMC_CCU8_SLICE_ClearEvent(HandlePtr->phase_ptr[2]->slice_ptr, XMC_CCU8_SLICE_IRQ_ID_TRAP);


  /* stop all slices */
  XMC_CCU8_SLICE_StopTimer(HandlePtr->phase_ptr[0]->slice_ptr);
  XMC_CCU8_SLICE_StopTimer(HandlePtr->phase_ptr[1]->slice_ptr);
  XMC_CCU8_SLICE_StopTimer(HandlePtr->phase_ptr[2]->slice_ptr);

  HandlePtr->state = PWM_BC_STOPPED;
}

/* This function writes the next multi channel pattern in shadow register */
void PWM_BC_SetNextMCPatt(PWM_BC_t* const HandlePtr, uint8_t Index)
{
  XMC_ASSERT("PWM_BC_SetNextMCPatt:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));
  XMC_POSIF_MCM_SetMultiChannelPattern
  ( 
    HandlePtr->posif_module_ptr, 
    (uint16_t)HandlePtr->mc_pattern[HandlePtr->modulation_type][(Index) +
                                        (uint8_t)HandlePtr->direction]
  );
}

/*This function updates compare value of the CCU8 slices*/
void PWM_BC_DutyCycleUpdate
(
  PWM_BC_t* HandlePtr,
  uint16_t dutycycle
)
{
  XMC_ASSERT("PWM_BC_DutyCycleUpdate:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));


  HandlePtr->ph_cmpval[3] = HandlePtr->period - dutycycle;
  HandlePtr->ph_cmpval[2] = dutycycle;

  XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[0]->slice_ptr,HandlePtr->config_ptr->phu_cmpch,
      HandlePtr->ph_cmpval[HandlePtr->ph_cmpflag[0]]);

  XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[1]->slice_ptr, HandlePtr->config_ptr->phv_cmpch,
      HandlePtr->ph_cmpval[HandlePtr->ph_cmpflag[1]]);

  XMC_CCU8_SLICE_SetTimerCompareMatch(HandlePtr->phase_ptr[2]->slice_ptr, HandlePtr->config_ptr->phw_cmpch,
      HandlePtr->ph_cmpval[HandlePtr->ph_cmpflag[2]]);

  XMC_CCU8_EnableShadowTransfer(HandlePtr->module_ptr,(uint32_t)HandlePtr->config_ptr->shadowtransfer_mask);
}

/** This function calculates the compare values based upon multi-channel pattern
 * and modulation type */
void PWM_BC_ModulationForImmedTransfer(PWM_BC_t* HandlePtr)
{
  uint8_t count;
  uint16_t mcmval;
  XMC_ASSERT("PWM_BC_CmpValCalc:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));

  mcmval = XMC_POSIF_MCM_GetMultiChannelPattern(HandlePtr->posif_module_ptr);

  if (PWM_BC_SYNCHRONOUS_RECTIFICATION_BALANCED_MOD == HandlePtr->modulation_type)
  {
    /* for synchronous rectification */
    PWM_BC_lImmeModulation_SyncRecti(HandlePtr);
  }
  else
  {
    for (count = (uint8_t)0; count < PWM_BC_MAXPHASE_COUNT; count++)
    {
      /* If high side switch is ON */
      if (HandlePtr->config_ptr->ph_mcpatt_compmask[count] ==
          (mcmval & (uint32_t)HandlePtr->config_ptr->ph_mcpatt_compmask[count]))
      {
        HandlePtr->ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
        XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[count]->slice_ptr,(uint8_t)0x0);
        /* For LowSide modulation type, high side switch duty = 100 % => ph_cmpflag = 0
         * For HighSide and Complementary modulation, high side switch duty = period - duty => ph_cmpflag = 3
         */
        if (PWM_BC_LOWSIDE_MOD == HandlePtr->modulation_type)
        {
          HandlePtr->ph_cmpflag[count] = PWM_BC_COMPARE_ZERO;
        }
        else if (((PWM_BC_SYNCHRONOUS_RECTIFICATION_MOD == HandlePtr->modulation_type)))
        {
          /* enable dead time for complementary modulation */
          XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[count]->slice_ptr,
                                                             HandlePtr->config_ptr->deadtime_control[count]);
        }
        else
        {
          /* Do nothing */
        }
      } /* End of high side switch is ON */
      /* if low side switch is ON */
      else if ((HandlePtr->config_ptr->ph_mcpatt_compmask[count] << 1U) ==
          (mcmval & (uint32_t)(HandlePtr->config_ptr->ph_mcpatt_compmask[count] << 1U)))
      {
        HandlePtr->ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
        /* disable dead time */
        XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[count]->slice_ptr,(uint8_t)0);

        /* For HighSide and Complementary modulation, low side switch duty = 100 % => ph_cmpflag = 1
         * For low side modulation type, low side switch duty = period - duty => ph_cmpflag = 3
         */
        if (PWM_BC_LOWSIDE_MOD == HandlePtr->modulation_type)
        {
          HandlePtr->ph_cmpflag[count] = PWM_BC_COMPARE_DUTY;
        }
      } /* End of low side switch is ON */
      /* if phase is not conducting */
      else
      {
        /* Do nothing */
      } /* End of phase is not conducting */
    } /* End of for loop */
  }
}

/** This function calculates the compare values based upon multi-channel pattern
 * and modulation type */
void PWM_BC_ModulationForSyncTransfer(PWM_BC_t* HandlePtr)
{
  uint8_t count;
  uint16_t mcmval;
  uint16_t mcmshadow;
  XMC_ASSERT("PWM_BC_CmpValCalc:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));

  mcmval = XMC_POSIF_MCM_GetMultiChannelPattern(HandlePtr->posif_module_ptr);
  mcmshadow = XMC_POSIF_MCM_GetShadowMultiChannelPattern(HandlePtr->posif_module_ptr);

  if (PWM_BC_SYNCHRONOUS_RECTIFICATION_BALANCED_MOD != HandlePtr->modulation_type)
  {
    for (count = (uint8_t)0; count < PWM_BC_MAXPHASE_COUNT; count++)
    {
      /* if phase is not conducting */
      if ((uint32_t)0 ==
          (mcmval & (uint32_t)HandlePtr->config_ptr->ph_bothside_compmask[count]))
      {
        /* If high side switch is ON */
        if (HandlePtr->config_ptr->ph_mcpatt_compmask[count] ==
            (mcmshadow & (uint32_t)HandlePtr->config_ptr->ph_mcpatt_compmask[count]))
        {
          HandlePtr->ph_cmpflag[count] = PWM_BC_COMPARE_INVERSE_DUTY;
          XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[count]->slice_ptr,(uint8_t)0);

          /* For LowSide modulation type, high side switch duty = 100 % => ph_cmpflag = 0
           * For HighSide and Complementary modulation, high side switch duty = period - duty => ph_cmpflag = 3
           */
          if (PWM_BC_LOWSIDE_MOD == HandlePtr->modulation_type)
          {
            HandlePtr->ph_cmpflag[count] = PWM_BC_COMPARE_ZERO;
          }
          else if (PWM_BC_SYNCHRONOUS_RECTIFICATION_MOD == HandlePtr->modulation_type)
          {
            /* enable dead time for complementary modulation */
            XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[count]->slice_ptr,HandlePtr->config_ptr->deadtime_control[count]);
          }
          else
          {
            /* Do nothing */
          }
        }
        /* if low side switch is ON */
        else if ((HandlePtr->config_ptr->ph_mcpatt_compmask[count] << 1U) ==
            (mcmshadow & (uint32_t)(HandlePtr->config_ptr->ph_mcpatt_compmask[count] << 1U)))
        {
          HandlePtr->ph_cmpflag[count] = PWM_BC_COMPARE_PERIOD;
          /* disable dead time */
          XMC_CCU8_SLICE_ConfigureDeadTime(HandlePtr->phase_ptr[count]->slice_ptr,(uint8_t)0);

          /* For HighSide and Complementary modulation, low side switch duty = 100 % => ph_cmpflag = 1
           * For low side modulation type, low side switch duty = period - duty => ph_cmpflag = 3
           */
          if (PWM_BC_LOWSIDE_MOD == HandlePtr->modulation_type)
          {
            HandlePtr->ph_cmpflag[count] = PWM_BC_COMPARE_DUTY;
          }
        }
        else
        {
          /* Do nothing */
        }
      }
      else
      {
        /* Do nothing */
      }
    }
  }
}

 /** This function changes the modulation type */
PWM_BC_STATUS_t PWM_BC_SetModulationType
(
  PWM_BC_t* HandlePtr,
  PWM_BC_MODULATIONTYPE_t modtype
)
{
  PWM_BC_STATUS_t status = PWM_BC_STATUS_SUCCESS;
  XMC_ASSERT("PWM_BC_SetModulationType:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));
  if (modtype < PWM_BC_MOD_MAX)
  {
    /* Update modulation type in dynamic handle */
    HandlePtr->modulation_type = modtype;
  }
  else
  {
    status  = PWM_BC_INVALID_PARAM;
  }
  return (status);
}

/** This function changes the direction of rotation */
PWM_BC_STATUS_t PWM_BC_SetDirection
(
  PWM_BC_t* HandlePtr,
  PWM_BC_Direction_t dir
)
{
  PWM_BC_STATUS_t status = PWM_BC_STATUS_SUCCESS;
  XMC_ASSERT("PWM_BC_SetDirection:NULL Handle Pointer",
            (HandlePtr != (PWM_BC_t *)NULL));
  if ((dir == PWM_BC_CLOCKWISE) || (dir == PWM_BC_ANTICLOCKWISE))
  {
    HandlePtr->direction = dir;
  }
  else
  {
    status  = PWM_BC_INVALID_PARAM;
  }
  return status;
}

/** This function reads the direction of rotation */
uint8_t PWM_BC_GetDirection(PWM_BC_t* HandlePtr)
{
  XMC_ASSERT("PWM_BC_SetDirection:NULL Handle Pointer",
                (HandlePtr != (PWM_BC_t *)NULL));

  return ((uint8_t)HandlePtr->direction);
}

/** This function updates the PWM frequency */
PWM_BC_STATUS_t PWM_BC_SetPWMFrequency(PWM_BC_t* HandlePtr, uint32_t Frequency)
{
  uint32_t pwm_time;
  uint16_t period;
  PWM_BC_STATUS_t status = PWM_BC_OPERATION_NOT_ALLOWED;
  XMC_ASSERT("PWM_BC_SetPWMFrequency:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));

  if ((PWM_BC_INITIALIZED == HandlePtr->state) ||
     (PWM_BC_STOPPED == HandlePtr->state))
  {
    if ((Frequency < HandlePtr->config_ptr->frequency_max) &&
        (Frequency > HandlePtr->config_ptr->frequency_min))
    {
      pwm_time = (HandlePtr->config_ptr->module_freq) / Frequency;

      period = (uint16_t)(pwm_time - 1U);

      XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[0]->slice_ptr, (uint16_t) period);
      XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[1]->slice_ptr, (uint16_t) period);
      XMC_CCU8_SLICE_SetTimerPeriodMatch(HandlePtr->phase_ptr[2]->slice_ptr, (uint16_t) period);

      /* update dynamic handle parameters */
      HandlePtr->period = period;
      status = PWM_BC_STATUS_SUCCESS;
    }
    else
    {
      status = PWM_BC_INVALID_PARAM;
    }
  }
  /*Enable the shadow transfer for all three slice*/
  XMC_CCU8_EnableShadowTransfer(HandlePtr->module_ptr, (uint32_t)HandlePtr->config_ptr->shadowtransfer_mask);
  return (status);
}  

/** This API function fetches the current PWM frequency */
uint32_t PWM_BC_GetPWMFrequency(PWM_BC_t* const HandlePtr)
{
  uint16_t period;
  uint32_t frequency;
  
  XMC_ASSERT("PWM_BC_GetPWMFrequency:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));

  period = XMC_CCU8_SLICE_GetTimerPeriodMatch(HandlePtr->phase_ptr[0]->slice_ptr);
  frequency = (uint32_t)((uint32_t)HandlePtr->config_ptr->module_freq / (period + (uint32_t)1));
  return (frequency);
} 

/** This API function gets the PWM modulation type*/
PWM_BC_MODULATIONTYPE_t PWM_BC_GetModulationType(PWM_BC_t* const HandlePtr)
{
  XMC_ASSERT("PWM_BC_GetModulationType:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));
  return (HandlePtr->modulation_type);
}

PWM_BC_STATUS_t PWM_BC_SetDeadTime(PWM_BC_t* HandlePtr, uint32_t DeadTimeRisingEdge,uint32_t DeadTimeFallingEdge)
{
  uint32_t deadtime_count;
  uint32_t deadtime_max;
  uint8_t prescaler = HandlePtr->deadtime_div;
  PWM_BC_STATUS_t status = PWM_BC_STATUS_SUCCESS;
  uint32_t dead_time_scale = ((HandlePtr->config_ptr->module_freq >> (uint32_t)prescaler)/PWM_BC_MILLISECCONV);
  /* Check for maximum dead time */
  if (DeadTimeRisingEdge > DeadTimeFallingEdge)
  {
    deadtime_max = DeadTimeRisingEdge;
  }
  else
  {
    deadtime_max = DeadTimeFallingEdge;
  }

  XMC_ASSERT("PWM_BC_SetDeadTime:NULL Handle Pointer",
              (HandlePtr != (PWM_BC_t *)NULL));

  if ((deadtime_max > PWM_BC_DEADTIME_MIN) && (deadtime_max < PWM_BC_DEADTIME_MAX))
  {
    deadtime_count = (uint32_t)((deadtime_max * dead_time_scale)/PWM_BC_MICROSECCONV);

    while ((deadtime_count > PWM_BC_DEADTIME_REG_MAX) && (prescaler <= PWM_BC_DEADTIME_DIV_MAX))
    {
      prescaler++;
      dead_time_scale = ((HandlePtr->config_ptr->module_freq >> (uint32_t)prescaler)/PWM_BC_MILLISECCONV);
      deadtime_count = (uint32_t)(deadtime_max * dead_time_scale);
      deadtime_count = (uint32_t)(deadtime_count/PWM_BC_MICROSECCONV);
    }

    if (DeadTimeRisingEdge > DeadTimeFallingEdge)
    {
      HandlePtr->dead_time_rising_edge   = (uint8_t)deadtime_count;
      HandlePtr->dead_time_falling_edge  = (uint8_t)((DeadTimeFallingEdge * dead_time_scale)/PWM_BC_MICROSECCONV);
    }
    else
    {
      HandlePtr->dead_time_falling_edge = (uint8_t)deadtime_count;
      HandlePtr->dead_time_rising_edge  = (uint8_t)((DeadTimeRisingEdge * dead_time_scale)/PWM_BC_MICROSECCONV);
    }

    XMC_CCU8_SLICE_SetDeadTimeValue(HandlePtr->phase_ptr[0]->slice_ptr,HandlePtr->config_ptr->phu_cmpch,
                                            HandlePtr->dead_time_rising_edge,HandlePtr->dead_time_falling_edge);
    XMC_CCU8_SLICE_SetDeadTimePrescaler(HandlePtr->phase_ptr[0]->slice_ptr,(XMC_CCU8_SLICE_DTC_DIV_t)prescaler);

    XMC_CCU8_SLICE_SetDeadTimeValue(HandlePtr->phase_ptr[1]->slice_ptr,HandlePtr->config_ptr->phv_cmpch,
                                            HandlePtr->dead_time_rising_edge,HandlePtr->dead_time_falling_edge);
    XMC_CCU8_SLICE_SetDeadTimePrescaler(HandlePtr->phase_ptr[1]->slice_ptr,(XMC_CCU8_SLICE_DTC_DIV_t)prescaler);

    XMC_CCU8_SLICE_SetDeadTimeValue(HandlePtr->phase_ptr[2]->slice_ptr,HandlePtr->config_ptr->phw_cmpch,
                                            HandlePtr->dead_time_rising_edge,HandlePtr->dead_time_falling_edge);
    XMC_CCU8_SLICE_SetDeadTimePrescaler(HandlePtr->phase_ptr[2]->slice_ptr,(XMC_CCU8_SLICE_DTC_DIV_t)prescaler);

    HandlePtr->deadtime_div = (uint8_t)prescaler;
  }
  else
  {
    status = PWM_BC_INVALID_PARAM;
  }
  return (status);
}

/* This API returns the rising edge dead time value in nanoseconds */
uint32_t PWM_BC_GetRisingEdgeDeadTime(PWM_BC_t* const HandlePtr)
{
  uint32_t deadtime;
  uint32_t dead_time_scale = (PWM_BC_NANOSECCONV/((HandlePtr->config_ptr->module_freq/PWM_BC_MILLISECCONV) >>
                                                          (uint32_t)HandlePtr->deadtime_div));
  /* calculate the deadtime from dead time count*/
  deadtime = (uint32_t)((HandlePtr->dead_time_rising_edge * dead_time_scale)/PWM_BC_MILLISECCONV);
  return (deadtime);
}

/* This API returns the falling edge dead time value in nanoseconds */
uint32_t PWM_BC_GetFallingEdgeDeadTime(PWM_BC_t* const HandlePtr)
{
  uint32_t deadtime;
  uint32_t dead_time_scale = (PWM_BC_NANOSECCONV/((HandlePtr->config_ptr->module_freq/PWM_BC_MILLISECCONV) >>
                                                          (uint32_t)HandlePtr->deadtime_div));
  /* calculate the deadtime from dead time count*/
  deadtime = (uint32_t)((HandlePtr->dead_time_falling_edge * dead_time_scale)/PWM_BC_MILLISECCONV);
  return (deadtime);
}


